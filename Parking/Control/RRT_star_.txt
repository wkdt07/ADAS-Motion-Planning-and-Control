function [x_path, y_path] = rrt_star_planner(map, startPose, goalPose, mapboundary)
    %% ===== Persistent 저장 =====
    persistent path_initialized x_path_cached y_path_cached nPath_cached
    maxPathLength = 500;
    resolution = 0.05;

    if isempty(path_initialized)
        path_initialized = false;
        x_path_cached = zeros(maxPathLength, 1);
        y_path_cached = zeros(maxPathLength, 1);
        nPath_cached = 1;
    end

    if path_initialized
        x_path = x_path_cached(1:nPath_cached);
        y_path = y_path_cached(1:nPath_cached);
        return;
    end

    %% 설정
    visualize      = false;
    maxIter        = 5000;
    stepSize       = 2;
    goalSampleRate = 0.1;
    successDistTh  = 5;
    collisionRes   = 0.5;
    searchRadius   = 10;
    safetyDist     = 2;

    %% 바운더리 기반 인덱스 변환용 파라미터
    x_values = mapboundary(1:2:end);
    y_values = mapboundary(2:2:end);
    x_min = min(x_values);
    y_max = max(y_values);

    %% 실좌표 → 인덱스 변환
    toGrid = @(x, y) [(x - x_min)/resolution +  1, (y_max - y)/resolution + 1];

    start_grid = toGrid(startPose(1), startPose(2));
    goal_grid  = toGrid(goalPose(1), goalPose(2));

    %% 트리 초기화 (모든 노드는 인덱스 좌표로 유지)
    nodes = struct('x', start_grid(1), 'y', start_grid(2), ...
                   'parent', 0, 'cost', 0);

    %% 경로 및 출력 초기화
    path   = struct('x', {}, 'y', {}, 'parent', {}, 'cost', {});
    x_path = zeros(maxPathLength, 1);
    y_path = zeros(maxPathLength, 1);

    %% RRT* 메인 루프 (모든 연산 인덱스 기반)
    for iter = 1:maxIter
        if rand < goalSampleRate
            xr = goal_grid;
        else
            xr = [randi([1, size(map,2)]), randi([1, size(map,1)])];
        end

        [nearestIdx, nearXY] = findNearest(nodes, xr);
        theta = atan2(xr(2)-nearXY(2), xr(1)-nearXY(1));
        newXY = nearXY + stepSize * [cos(theta), sin(theta)];

        if isCollision(newXY, map) || ...
           isPathCollision(nearXY, newXY, map, collisionRes) || ...
           isNearObstacle(newXY, map, safetyDist / resolution)
            continue;
        end

        nearIdxs = findNearNodes(nodes, newXY, searchRadius);
        minCost   = nodes(nearestIdx).cost + norm(newXY - nearXY);
        minParent = nearestIdx;

        for idx = 1:numel(nearIdxs)
            iNode = nearIdxs(idx);
            pxy   = [nodes(iNode).x, nodes(iNode).y];
            if ~isPathCollision(pxy, newXY, map, collisionRes)
                c = nodes(iNode).cost + norm(newXY - pxy);
                if c < minCost
                    minCost   = c;
                    minParent = iNode;
                end
            end
        end

        newNode = struct('x', newXY(1), 'y', newXY(2), ...
                         'parent', minParent, 'cost', minCost);
        nodes(end+1) = newNode;
        newIdx       = numel(nodes);

        for idx = 1:numel(nearIdxs)
            iNode = nearIdxs(idx);
            pxy   = [nodes(iNode).x, nodes(iNode).y];
            c     = newNode.cost + norm([newNode.x, newNode.y] - pxy);
            if c < nodes(iNode).cost && ...
               ~isPathCollision([newNode.x,newNode.y], pxy, map, collisionRes)
                nodes(iNode).parent = newIdx;
                nodes(iNode).cost   = c;
            end
        end

        if visualize
            plot([nodes(newNode.parent).x, newNode.x], ...
                 [nodes(newNode.parent).y, newNode.y], '-r');
            hold on;
        end

        if norm(newXY - goal_grid) < successDistTh
            if visualize, disp('[-] GOAL REACHED'); end
            path = backtrace(nodes, newIdx);
            break;
        end
    end

    %% 결과 경로 반환 (인덱스 → 실좌표로 역변환)
    nPath = min(numel(path), maxPathLength);
    x_path_cached = zeros(maxPathLength, 1);
    y_path_cached = zeros(maxPathLength, 1);
    for k = 1:nPath
        x_path_cached(k) = (path(k).x - 1) * resolution + x_min;
        y_path_cached(k) = y_max - (path(k).y - 1) * resolution;
    end

    nPath_cached = nPath;
    path_initialized = true;

    %% === Lightweight Smoothing for Simulink Compatibility ===
    smooth_window = 15;  % 홀수 추천
    if nPath >= smooth_window
        x = x_path_cached(1:nPath);
        y = y_path_cached(1:nPath);

        x_smooth = movmean(x, smooth_window);
        y_smooth = movmean(y, smooth_window);

        % 재샘플링 (고정된 개수로)
        smoothN = 100;
        idx_original = linspace(1, numel(x_smooth), smoothN);
        x_path = interp1(1:numel(x_smooth), x_smooth, idx_original, 'linear')';
        y_path = interp1(1:numel(y_smooth), y_smooth, idx_original, 'linear')';
    else
        x_path = x_path_cached(1:nPath);
        y_path = y_path_cached(1:nPath);
    end


end

%% ======= 서브 함수들 =======

function [idx, xy] = findNearest(nodes, sampleXY)
    d = arrayfun(@(n) hypot(n.x - sampleXY(1), n.y - sampleXY(2)), nodes);
    [~, idx] = min(d);
    xy = [nodes(idx).x, nodes(idx).y];
end

function nearIdxs = findNearNodes(nodes, pos, radius)
    maxNodes = 1000;
    nearIdxs = zeros(1, maxNodes);
    count = 0;
    for i = 1:numel(nodes)
        if hypot(nodes(i).x - pos(1), nodes(i).y - pos(2)) <= radius
            count = count + 1;
            nearIdxs(count) = i;
        end
    end
    nearIdxs = nearIdxs(1:count);
end

function flag = isCollision(pt, map)
    x = round(pt(1)); y = round(pt(2));
    flag = x < 1 || x > size(map,2) || y < 1 || y > size(map,1) || map(y,x) == 1;
end

function flag = isPathCollision(p1, p2, map, step)
    dist = norm(p2 - p1);
    N = max(1, ceil(dist / step));
    flag = false;
    for i = 0:N
        pt = p1 + (p2 - p1) * (i / N);
        if isCollision(pt, map)
            flag = true; return;
        end
    end
end

function flag = isNearObstacle(pt, map, safeDist)
    x0 = round(pt(1)); y0 = round(pt(2));
    r  = ceil(safeDist);
    [X, Y] = meshgrid((x0 - r):(x0 + r), (y0 - r):(y0 + r));
    D2 = (X - pt(1)).^2 + (Y - pt(2)).^2;
    mask = D2 <= safeDist^2;
    X = X(mask); Y = Y(mask);
    valid = X >= 1 & X <= size(map,2) & Y >= 1 & Y <= size(map,1);
    flag  = any(map(sub2ind(size(map), Y(valid), X(valid))) == 1);
end

function path = backtrace(nodes, idx)
    maxPathLen = 500;
    dummyNode = struct('x', 0, 'y', 0, 'parent', 0, 'cost', 0);
    path = repmat(dummyNode, maxPathLen, 1);
    count = 0;
    while idx ~= 0 && count < maxPathLen
        count = count + 1;
        path(count) = nodes(idx);
        idx = nodes(idx).parent;
    end
    path = path(count:-1:1);
end